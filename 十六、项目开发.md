# 十六、项目开发

## 16.1 目录划分

为了方便我们以后程序开发，第一步是将目录进行划分

### 16.1.1 assets静态资源

assets位于src目录下，存放我们的静态资源我们可以在文件夹下新建两个文件夹img和css，用来存放图片及css文件。

### 16.1.2 components 组件文件夹

components文件夹位于sec目录下，文件夹存放所有公用的组件，即一些许多页面都需要用到的公用的组件，而公共组件又可以分为两类：

1 common 通用组件

​	该文件夹下存放的组件不仅仅可以在本项目中通用，在其他项目中也可以通用

2 content 业务组件

​	只为当前项目服务的业务组件

### 16.1.2 views组件文件夹

该文件夹位于src目录下，存放一些比较大的页面，不通用的组件，在文件夹中，又可以新建文件夹对应每一个大页面。

### 16.1.3 router路由文件夹

router文件夹位于src目录下，路由相关的文件将被存放到该文件夹下面

### 16.1.4 store状态管理文件夹

store文件夹位于src目录下，存放状态管理的文件

### 16.1.5 network网络相关文件夹

network文件夹位于src目录下，存放网络请求的相关文件

### 16.1.6 common公用文件夹

common文件夹位于src目录下，用于存放一些基础、公用的js文件，比如一些常量集中存放在const文件下，或者一些公用的方法

## 16.2 CSS文件的引入

### 16.2.1 normalize.css文件

不同浏览器对css的初始化并不一样，通过该css文件能够将css初始化统一，在github上下载，并在base.css文件中导入该css文件。

```
@import "@/assets/css/normalize.css"
```

### 16.2.2 base.css文件

属于自己的一些基础的样式文件，我们在github上搜索supermall/codewhy下载该文件,最后在App.vue文件中引入该文件。

```
@import "@/assets/css/base.css"
```

### 16.2.3 tips  

:root表示根元素，即html元素

css中也可以定义变量，`--varriate：19px`，后面如果要调用该变量，只需要通过var来调用

```
font-size:var(--variate);
```

## 16.3 设置路径别名

### 16.3.1 配置文件

vuecli3和vuecli4将配置文件隐藏在了node_modules的@vue中，我们需要在项目目录（与src同一级目录）中新建一个vue.config.js来设置配置。

```
module.exports={
  configureWebpack:{
    resolve:{
      alias:{
        "@" :'/src',
        "assets":"@/assets",
        "components":"@/components",
        "views" :"@/views",
        "store" :"@/store",
        "network" :"@/network"
      }
    }
  }
}
```

在VueCli4中，以上的设置系统里其实已经设置好，可以直接使用，需要注意的是：

1 css的引入中，有两种方法：

```
import "~@/assets/css/base.css"
import "assets/css/base.css"
```

使用@引入css一定要在前面加上~

## 16.4 程序编写配置

文件为.editorconfig，主要配置一些诸如缩进，换行的配置，在VueCLI4中已经没有该文件，我们去网上下载或者使用插件来规范编写。

## 16.5 将之前做的tabbar复制过来

### 16.5.1 tabbar目录的划分

1 tabbar中的文件TabBar、TabBarItem这些可以在多个项目中复用的我们放在components/common/tabbar文件夹中

2 而mainTabba中的文件MainTarbar是对TabBar和TabBarItem进行插槽的个性内容，与本项目关联，需要放在components/content/mainTabbar文件夹中

3 对于项目的大视图我们则在view新建文件夹对应各个试图，并将视图放到对应文件夹中，各个视图相关组件都可以放在该文件夹下。

![image-20211020211235686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020211235686.png)

### 16.5.3 img目录的划分

在img中我们继续新建tabbar文件夹，以及home、category文件夹，用于存放对应组件的图片。

### 16.5.3 VueCli3 vue-router

注意VuelCli3中，vue-router，不再是导入vue-router后，再用Vue.use(vue-router),而是，如下：

```
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path:'/',
    redirect:'/home'
  },
  {
    path: '/home',
    name: 'Home',
    component: () => import(/* webpackChunkName: "about" */ 'views/Home.vue')
  },
  {
    path: '/category',
    name: 'CateGgory',
    component: () => import(/* webpackChunkName: "about" */ 'views/Category.vue')
  },
  {
    path: '/cart',
    name: 'Cart',
    component: () => import(/* webpackChunkName: "about" */ 'views/Cart.vue')
  },
  {
    path: '/profile',
    name: 'Profile',
    component: () => import(/* webpackChunkName: "about" */ 'views/Profile.vue')
  }
]
const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router

```

使用中可能还会出现一个问题，你安装了vue-router,却会出现vue-router未导出createRouter和createWbeHhistory，这里我们需要再执行以下:

`npm install vue-router@next --save`

在main.js中引用router也与之前不一样：

```
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

createApp(App).use(router).mount('#app')
```



### 16.5.4 具名插槽

在VUE3中，具名插槽做了变更

插槽形式没变` <slot name='item-img'></slot>`

插入插槽时有了变化：

```
 <template v-slot:item-img>
    <img src="~assets/img/tabbar/shopcart.svg" alt="">
 </template>
```

可以简写为：

```
 <template #item-img>
    <img src="~assets/img/tabbar/shopcart.svg" alt="">
 </template>
```

### 16.5.5 浏览器网页图标更改

代码位于public 中index.html：

```
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
```

## 16.6 navibar 导航条的封装

### 16.6.1 划分目录

在components文件夹common中新建navbar文件夹，因为navbar不仅仅可以在本目录使用，在其他项目也可以使用，并新建NavBar.vue文件，将导航条分为左中右三部分，分别设置了插槽，注意样式一定不要放在插槽中，而是用div将插槽包裹，将样式写在div中。

```
<template>
  <div class="nav-bar">
    <div class='left'>
        <slot name='left'></slot>
    </div>
    <div class='center'>
        <slot name='center'></slot>
    </div>
    <div class='right'>
        <slot name='right'></slot>
    </div>
  </div>
</template>

<script>
export default {
    name:'NavBar'
}
</script>

<style>
  .nav-bar{
    display: flex;
    line-height:44px;
    height:44px;
  }
.left,.right{
    width:60px;
    background-color: #fff;

}
.center{
  flex:1;
  background-color: red;
}

</style>
```

### 16.6.2 调用NavBar组件

接下来我们就可以在视图中调用NavBar组件，并进行个性化的处理

1 Home组件

在Home组件中调用我们的NavBar组件，并对home组件中的NavBar进行一些个性化的修饰：

```
<template>
  <div>
      <nav-bar class='home-nav'>
        <template #center>
          <div>购物街</div>
        </template>
      </nav-bar>
  </div>
</template>

<script>
import NavBar from "components/common/navbar/NavBar"
export default {
    name:"Home",
    components:{
      NavBar
    }
}
</script>

<style>
  .home-nav{
    background-color:var(--color-tint);
    color:white;
  }
</style>
```

## 16.7 请求首页数据

网络封装request.js在之前已经做好，具体可以参考十五、网络模块的封装，我们将文件拷贝到network文件夹中，记得安装axios插件哦。

### 16.7.1 二次封装

网络请求封装为request.js后，我们如果把网络请求放在每个组件中，会让组件耦合度不足，此时我们可以进行二次封装，对组件，比如home组件，需要的网络请求统统封装到home.js中去，然后通过导入home.js中的网络请求方法来获得数据，这样做法也方便我们对页面数据请求进行管理。

首先在home.js中导入request模块

```
import {request} from "./request";
```

然后在home.js中定义请求数据：

```
export function getHomeMultidata() {
  return request({
    url: '/home/multidata'
  })
}
```

此时我们在Home.vue组件中请求数据只需要导入home.js中的getHomeMultidata，进行数据请求

```
import {getHomeMultidata} from 'network/home'
```

```
created(){
      getHomeMultidata().then(data=>{
        console.log(data)
      })
    }
```

如果Home还有其他的数据请求，同样可以在home.js中定义，并在Home.vue中定义

此时我们在Home.vue中定义一个变量，用来存放网络请求来的数据。

```
    data(){
      return {
        result:null,
      }
    },
    created(){
      getHomeMultidata().then(data=>{
        this.result=data
      })
    }
```

如果网络请求来的数据包含多个数组，要在then中取数据时做好数据分割。

```
 data(){
      return {
        banner:[],
        recommend:[],
      }
    },
    created(){
      getHomeMultidata().then(data=>{
        this.banner=data.data.banner,
        recommend=data.data.recommend
      })
    }
```

整体取过来，在去取数组容易出错。

## 16.8 轮播图展示

此时我们已经请求到相应数据，接下就是进行相关的展示

轮播图视频中进行了封装，放在components/common/swiper中，这是可以进行复用的，我们拷贝进来，然后在Home.vue中进行使用：

```
import Swiper from './Swiper'
import SwiperItem from './SwiperItem'
export {
  Swiper, SwiperItem
}
```

这里还做了个处理，在swiper文件夹中，新建index.js文件，导入了Swiper，SwiperItem，并导出，那么在Home.vue中导入只需要：

```
import {Swiper,SwiperItem} from 'components/common/swiper/index'
```

并引入两个组件：

```
<swiper>
        <swiper-item v-for="item in banner" :key='item.title'>
          <a :href="item.link">
            <img :src="item.image" alt="">
          </a>
        </swiper-item>
      </swiper>
```

这里v-for 要加上:key,不然会报错，当然使用起来没有影响。

到这里轮播图就可以正常显示了，但是本着封装的思想，我们可以将这块代码封装为HomeSwiper，直接在Home调用组件，首先在views/home/中新建文件夹childComponents,在文件夹中新建HomeSwiper.vue文件，将代码放入，这里注意网络请求还是在Home中，数据可以通过props传入。

```
<template>
  <swiper>
        <swiper-item v-for="item in banner" :key='item.title'>
          <a :href="item.link">
            <img :src="item.image" alt="">
          </a>
        </swiper-item>
      </swiper>
</template>

<script>
import {Swiper,SwiperItem} from 'components/common/swiper/index'
export default {
    name:'HomeSwiper',
    components:{
        Swiper,
        SwiperItem
    },props:{
        banner:{
            type:Array,
            default(){
                return []
            }
        }
    }
}
</script>

<style>

</style>
```

上面有个知识点要注意一下，props中给数组或对象赋予默认值时，要通过方法返回。

在Home.vue中调用，并传入值

```
<home-swiper :banner='banner'></home-swiper>
```

## 16.7 4张介绍图片

和HomeSwiper相同，也是在childComponents中先写好代码，直接在Home中引入。

```
<template>
    <div class="recommend">
        <div v-for='(item,index) in recommend' :key='index' class='recommend-item'>
            <a :href="item.link">
                <img :src="item.image" alt="">
                <div>{{item.title}}</div>
            </a>
            
        </div>
    </div>
</template>

<script>
export default {
    name:'RecommendView',
    props:{
        recommend:{
            type:Array,
            default(){
                return []
            }
        }
    },
}
</script>

<style>
    .recommend{
        display:flex;
        text-align: center;
        font-size:12px;
        padding:10px 0 20px;
        border-bottom:8px solid #eee;
    }
    .recommend-item{
        flex:1;
    }
    .recommend-item img{
        height:80%;
        width:80%;
        margin-bottom:10px;
    }
</style>
```

Home中引入：

```
 <recommend-view :recommend='recommend'></recommend-view>
```

### 16.8 TabControl

接下来我们来做一下home中的控制卡，具体代码在项目中，可以去看一下，由于TabControl属于本项目会使用，其他项目不使用的组件，我们放在了components/content/tabcontrol中。

需要注意的有一个粘性定位：

```
.tab-control{
    position: sticky;
    top:44px;
  }
```

即当页面移动到控制卡，同时控制卡距离页面顶端只有44px时，控制卡不会在移动，而是定位在这个位置。

![image-20211025170128046](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211025170128046.png)

这个属性比较新，一些旧的浏览器可能不能使用。

## 16.9 商品数据

首先在request.js中设置网络请求：

```
export function getHomeGoods(type, page) {
  return request({
    url: '/home/data',
    params: {
      type, 
      page
    }
  })
}
```

直接调用封装好的requets，并将url以及参数传入。

接下来我们就可以在页面上导入该网络请求，并在vue创建时调用，这里朱注意哦，因为数据拿到之后可能还会对数据进行处理，建议是将网络请求封装到方法中，然后在created中通过this来调用：

```
created(){
      this.getHomeMultidata(),
      this.getHomeGoods('pop'),
      this.getHomeGoods('new'),
      this.getHomeGoods('sell')
    },
    methods:{
      getHomeMultidata(){
        getHomeMultidata().then(data=>{
        this.banner=data.data.banner.list,
        this.recommend=data.data.recommend.list
        })
      },
      getHomeGoods(type){
       let page=this.goods[type].page+1;
         getHomeGoods(type,page).then(data=>{
          this.goods[type].list.push(...data.data.list);
          this.goods[type].page+=1
         }) 
      }
    }
```

这里有两个知识点需要注意：

1  如果对象的键是一个字符串，我们可以用两种方法来调用，this.data['pop']或者this.data.pop,但是如果调用时不是直接调用键的字符串，而是一个变量来通用的调用，就一定要用this.data[type]的形式。

2 push可以将一个数组中的所有元素插入到另一个数组中，a.push(...b)

## 16.10 商品展示

商品展示只会在本项目中使用，我们在content中创建goods文件夹，并在里面创建GoodsList和GoodsListItem组件

分别用来放置所有商品，和单个商品，再将GoodsListItem放入GoodsList，最后放入到Home组件中，数据传输通过组件进行。

## 16.11 点击tabControl，更换页面显示内容

点击内容发声在TabControl中，我们通过emit来监控这次点击事件，并且将数据传出组件：

```
 methods:{
        itemClick(index){
            this.currentIndex=index;
            this.$emit('tabClick',index)
        }
    }    
```

接下来，我们要到Home中的Tabcontrol，自定义tabClick

```
<TabControl :title="['娜美','莉莉丝','利亚纳']" class='tab-control' @tabClick='changeTab'/>
```

注意哦，`this.$emit('tabClick',index)`传过来了一个参数，但是@tabClick='changeTab'中的changeTab并不能展示参数，而是在方法定义中展示。

此时我们点击TabControl，就会触发changeTable函数，而changeTable函数要实现更换商品页面数据类型'pop'\'、“sell”、“new”



```
     changeTab(index){
      //  switch(index){
      //    case 0 :
      //      this.currentType='pop';
      //      break;
      //   case 1:
      //     this.currentType='sell';
      //     break;
      //   case 2 : 'new';
      //     this.currentType='new'
      //     break
      //  }
      console.log(index)
     }
```

此时我们就完成了商品数据的切换。

## 16.12 better-scroll滚动条

### 16.12.1 基本使用

1 安装better-scroll

`npm install better-scroll --save`

2 引入better-scroll

```
import BScroll  from 'better-scroll'
```

3 创建better-scroll实例

```
new BScroll(document.querySelector('.wrapper'),{


```

注意哦，`document.querySelector('.wrapper')`,是获取dom，将`<div class='wrapper'></div>`获取，其他获取dom的方式也是可以的。

### 16.12.2 进阶用法

1  注意better-scroll获取到的dom里的元素可以实现新的滚动，但是只会作用于第一个子元素！

2 better-scroll是一个针对于移动端的插件

3 wrapper样式最好是包裹在滚动内容的上一层：

```
    <div class="content">
        <ul>
            <li>明渊</li>
			。。。
        </ul>
    </div>
```

样式写在content上

4 现在可以安装完整库betterscroll或者是核心库core,但用法不一样

core,如果你只需要一个拥有基础滚动能力的列表，只需要引入 core。：

```js
<script src="https://unpkg.com/@better-scroll/core@latest/dist/core.js"></script>
let bscroll = new BScroll(wrapper, {})
```

better-scroll,完整的滚动库:

```
<script src="https://unpkg.com/better-scroll@latest/dist/better-scroll.js"></script>
let bs = BetterScroll.createBScroll('.wrapper', {})
```

可以看到哦，core中BScroll是构造函数，而到了better-scroll完整库里BetterScroll才是，但是两个得到的结果都是构造函数，是一样的。

5 获取滚动的位置：

```
const bscroll=new BScroll(document.querySelector('.content'),{
     probeType:1,
    })
bscroll.on('scroll',(position)=>{
    console.log(position)
    })
```

这里构造函数中的option提供了一个`probeType`，侦测函数，当函数值为0时，表示不侦测，为1时，表示延时侦测，为2时表示手指滚动时侦测，而手指离开的惯性不侦测，为3表示手指离开惯性的过程也侦测，只要是滚动都侦测。

后面显示位置的函数还可以对position进行解构：

```
 bs.on('scroll',({y})=>{
    console.log(y)

  })
```

7 点击监听

据官方说，better-scroll中是将点击监听关闭了，需要在构造函数中的option，设置click:true，来启用点击监听。

8 上拉加载更多

首先在构造函数中，设置option

```
const bs=BetterScroll.createBScroll('.content',{
        probeType:1,
        pullUpLoad:true,

    })
```

然后调用事件pullingUp:

```
    bs.on('pullingUp',()=>{
        console.log('上拉加载更多')
    })
```

但是一定要在调用的末尾设置上拉加载结束，否则无法进行下一次上拉加载

```
   bs.on('pullingUp',()=>{
        console.log('上拉加载更多')
        bs.finishPullUp()
    })
```

