# 十六、项目开发

## 16.1 目录划分

为了方便我们以后程序开发，第一步是将目录进行划分

### 16.1.1 assets静态资源

assets位于src目录下，存放我们的静态资源我们可以在文件夹下新建两个文件夹img和css，用来存放图片及css文件。

### 16.1.2 components 组件文件夹

components文件夹位于sec目录下，文件夹存放所有公用的组件，即一些许多页面都需要用到的公用的组件，而公共组件又可以分为两类：

1 common 通用组件

​	该文件夹下存放的组件不仅仅可以在本项目中通用，在其他项目中也可以通用

2 content 业务组件

​	只为当前项目服务的业务组件

### 16.1.2 views组件文件夹

该文件夹位于src目录下，存放一些比较大的页面，不通用的组件，在文件夹中，又可以新建文件夹对应每一个大页面。

### 16.1.3 router路由文件夹

router文件夹位于src目录下，路由相关的文件将被存放到该文件夹下面

### 16.1.4 store状态管理文件夹

store文件夹位于src目录下，存放状态管理的文件

### 16.1.5 network网络相关文件夹

network文件夹位于src目录下，存放网络请求的相关文件

### 16.1.6 common公用文件夹

common文件夹位于src目录下，用于存放一些基础、公用的js文件，比如一些常量集中存放在const文件下，或者一些公用的方法

## 16.2 CSS文件的引入

### 16.2.1 normalize.css文件

不同浏览器对css的初始化并不一样，通过该css文件能够将css初始化统一，在github上下载，并在base.css文件中导入该css文件。

```
@import "@/assets/css/normalize.css"
```

### 16.2.2 base.css文件

属于自己的一些基础的样式文件，我们在github上搜索supermall/codewhy下载该文件,最后在App.vue文件中引入该文件。

```
@import "@/assets/css/base.css"
```

### 16.2.3 tips  

:root表示根元素，即html元素

css中也可以定义变量，`--varriate：19px`，后面如果要调用该变量，只需要通过var来调用

```
font-size:var(--variate);
```

## 16.3 设置路径别名

### 16.3.1 配置文件

vuecli3和vuecli4将配置文件隐藏在了node_modules的@vue中，我们需要在项目目录（与src同一级目录）中新建一个vue.config.js来设置配置。

```
module.exports={
  configureWebpack:{
    resolve:{
      alias:{
        "@" :'/src',
        "assets":"@/assets",
        "components":"@/components",
        "views" :"@/views",
        "store" :"@/store",
        "network" :"@/network"
      }
    }
  }
}
```

在VueCli4中，以上的设置系统里其实已经设置好，可以直接使用，需要注意的是：

1 css的引入中，有两种方法：

```
import "~@/assets/css/base.css"
import "assets/css/base.css"
```

使用@引入css一定要在前面加上~

## 16.4 程序编写配置

文件为.editorconfig，主要配置一些诸如缩进，换行的配置，在VueCLI4中已经没有该文件，我们去网上下载或者使用插件来规范编写。

## 16.5 将之前做的tabbar复制过来

### 16.5.1 tabbar目录的划分

1 tabbar中的文件TabBar、TabBarItem这些可以在多个项目中复用的我们放在components/common/tabbar文件夹中

2 而mainTabba中的文件MainTarbar是对TabBar和TabBarItem进行插槽的个性内容，与本项目关联，需要放在components/content/mainTabbar文件夹中

3 对于项目的大视图我们则在view新建文件夹对应各个试图，并将视图放到对应文件夹中，各个视图相关组件都可以放在该文件夹下。

![image-20211020211235686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020211235686.png)

### 16.5.3 img目录的划分

在img中我们继续新建tabbar文件夹，以及home、category文件夹，用于存放对应组件的图片。

### 16.5.3 VueCli3 vue-router

注意VuelCli3中，vue-router，不再是导入vue-router后，再用Vue.use(vue-router),而是，如下：

```
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path:'/',
    redirect:'/home'
  },
  {
    path: '/home',
    name: 'Home',
    component: () => import(/* webpackChunkName: "about" */ 'views/Home.vue')
  },
  {
    path: '/category',
    name: 'CateGgory',
    component: () => import(/* webpackChunkName: "about" */ 'views/Category.vue')
  },
  {
    path: '/cart',
    name: 'Cart',
    component: () => import(/* webpackChunkName: "about" */ 'views/Cart.vue')
  },
  {
    path: '/profile',
    name: 'Profile',
    component: () => import(/* webpackChunkName: "about" */ 'views/Profile.vue')
  }
]
const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router

```

使用中可能还会出现一个问题，你安装了vue-router,却会出现vue-router未导出createRouter和createWbeHhistory，这里我们需要再执行以下:

`npm install vue-router@next --save`

在main.js中引用router也与之前不一样：

```
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

createApp(App).use(router).mount('#app')
```



### 16.5.4 具名插槽

在VUE3中，具名插槽做了变更

插槽形式没变` <slot name='item-img'></slot>`

插入插槽时有了变化：

```
 <template v-slot:item-img>
    <img src="~assets/img/tabbar/shopcart.svg" alt="">
 </template>
```

可以简写为：

```
 <template #item-img>
    <img src="~assets/img/tabbar/shopcart.svg" alt="">
 </template>
```

### 16.5.5 浏览器网页图标更改

代码位于public 中index.html：

```
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
```

## 16.6 navibar 导航条的封装

### 16.6.1 划分目录

在components文件夹common中新建navbar文件夹，因为navbar不仅仅可以在本目录使用，在其他项目也可以使用，并新建NavBar.vue文件，将导航条分为左中右三部分，分别设置了插槽，注意样式一定不要放在插槽中，而是用div将插槽包裹，将样式写在div中。

```
<template>
  <div class="nav-bar">
    <div class='left'>
        <slot name='left'></slot>
    </div>
    <div class='center'>
        <slot name='center'></slot>
    </div>
    <div class='right'>
        <slot name='right'></slot>
    </div>
  </div>
</template>

<script>
export default {
    name:'NavBar'
}
</script>

<style>
  .nav-bar{
    display: flex;
    line-height:44px;
    height:44px;
  }
.left,.right{
    width:60px;
    background-color: #fff;

}
.center{
  flex:1;
  background-color: red;
}

</style>
```

### 16.6.2 调用NavBar组件

接下来我们就可以在视图中调用NavBar组件，并进行个性化的处理

1 Home组件

在Home组件中调用我们的NavBar组件，并对home组件中的NavBar进行一些个性化的修饰：

```
<template>
  <div>
      <nav-bar class='home-nav'>
        <template #center>
          <div>购物街</div>
        </template>
      </nav-bar>
  </div>
</template>

<script>
import NavBar from "components/common/navbar/NavBar"
export default {
    name:"Home",
    components:{
      NavBar
    }
}
</script>

<style>
  .home-nav{
    background-color:var(--color-tint);
    color:white;
  }
</style>
```

## 16.7 请求首页数据

网络封装request.js在之前已经做好，具体可以参考十五、网络模块的封装，我们将文件拷贝到network文件夹中，记得安装axios插件哦。

### 16.7.1 二次封装

网络请求封装为request.js后，我们如果把网络请求放在每个组件中，会让组件耦合度不足，此时我们可以进行二次封装，对组件，比如home组件，需要的网络请求统统封装到home.js中去，然后通过导入home.js中的网络请求方法来获得数据，这样做法也方便我们对页面数据请求进行管理。

首先在home.js中导入request模块

```
import {request} from "./request";
```

然后在home.js中定义请求数据：

```
export function getHomeMultidata() {
  return request({
    url: '/home/multidata'
  })
}
```

此时我们在Home.vue组件中请求数据只需要导入home.js中的getHomeMultidata，进行数据请求

```
import {getHomeMultidata} from 'network/home'
```

```
created(){
      getHomeMultidata().then(data=>{
        console.log(data)
      })
    }
```

如果Home还有其他的数据请求，同样可以在home.js中定义，并在Home.vue中定义

此时我们在Home.vue中定义一个变量，用来存放网络请求来的数据。

```
    data(){
      return {
        result:null,
      }
    },
    created(){
      getHomeMultidata().then(data=>{
        this.result=data
      })
    }
```

如果网络请求来的数据包含多个数组，要在then中取数据时做好数据分割。

```
 data(){
      return {
        banner:[],
        recommend:[],
      }
    },
    created(){
      getHomeMultidata().then(data=>{
        this.banner=data.data.banner,
        recommend=data.data.recommend
      })
    }
```

整体取过来，在去取数组容易出错。

## 16.8 轮播图展示

此时我们已经请求到相应数据，接下就是进行相关的展示

轮播图视频中进行了封装，放在components/common/swiper中，这是可以进行复用的，我们拷贝进来，然后在Home.vue中进行使用：

```
import Swiper from './Swiper'
import SwiperItem from './SwiperItem'
export {
  Swiper, SwiperItem
}
```

这里还做了个处理，在swiper文件夹中，新建index.js文件，导入了Swiper，SwiperItem，并导出，那么在Home.vue中导入只需要：

```
import {Swiper,SwiperItem} from 'components/common/swiper/index'
```

并引入两个组件：

```
<swiper>
        <swiper-item v-for="item in banner" :key='item.title'>
          <a :href="item.link">
            <img :src="item.image" alt="">
          </a>
        </swiper-item>
      </swiper>
```

这里v-for 要加上:key,不然会报错，当然使用起来没有影响。

到这里轮播图就可以正常显示了，但是本着封装的思想，我们可以将这块代码封装为HomeSwiper，直接在Home调用组件，首先在views/home/中新建文件夹childComponents,在文件夹中新建HomeSwiper.vue文件，将代码放入，这里注意网络请求还是在Home中，数据可以通过props传入。

```
<template>
  <swiper>
        <swiper-item v-for="item in banner" :key='item.title'>
          <a :href="item.link">
            <img :src="item.image" alt="">
          </a>
        </swiper-item>
      </swiper>
</template>

<script>
import {Swiper,SwiperItem} from 'components/common/swiper/index'
export default {
    name:'HomeSwiper',
    components:{
        Swiper,
        SwiperItem
    },props:{
        banner:{
            type:Array,
            default(){
                return []
            }
        }
    }
}
</script>

<style>

</style>
```

上面有个知识点要注意一下，props中给数组或对象赋予默认值时，要通过方法返回。

在Home.vue中调用，并传入值

```
<home-swiper :banner='banner'></home-swiper>
```

## 16.7 4张介绍图片

和HomeSwiper相同，也是在childComponents中先写好代码，直接在Home中引入。

```
<template>
    <div class="recommend">
        <div v-for='(item,index) in recommend' :key='index' class='recommend-item'>
            <a :href="item.link">
                <img :src="item.image" alt="">
                <div>{{item.title}}</div>
            </a>
            
        </div>
    </div>
</template>

<script>
export default {
    name:'RecommendView',
    props:{
        recommend:{
            type:Array,
            default(){
                return []
            }
        }
    },
}
</script>

<style>
    .recommend{
        display:flex;
        text-align: center;
        font-size:12px;
        padding:10px 0 20px;
        border-bottom:8px solid #eee;
    }
    .recommend-item{
        flex:1;
    }
    .recommend-item img{
        height:80%;
        width:80%;
        margin-bottom:10px;
    }
</style>
```

Home中引入：

```
 <recommend-view :recommend='recommend'></recommend-view>
```

### 16.8 TabControl

接下来我们来做一下home中的控制卡，具体代码在项目中，可以去看一下，由于TabControl属于本项目会使用，其他项目不使用的组件，我们放在了components/content/tabcontrol中。

需要注意的有一个粘性定位：

```
.tab-control{
    position: sticky;
    top:44px;
  }
```

即当页面移动到控制卡，同时控制卡距离页面顶端只有44px时，控制卡不会在移动，而是定位在这个位置。

![image-20211025170128046](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211025170128046.png)

这个属性比较新，一些旧的浏览器可能不能使用。
